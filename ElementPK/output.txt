-- FreeFem++ v4.15 (mer. 01 oct. 2025 15:29:50 CEST - git v4.15-136-g831473f55)
   file : test.edp
 Load: lg_fem lg_mesh lg_mesh3 eigenvalue 
    1 : load"Element_Pk"
START
Point -->0( 5 0 0 )
Point -->1( 0 5 0 )
Point -->2( 0 0 5 )
Point -->3( 0 4 1 )
Point -->4( 0 3 2 )
Point -->5( 0 2 3 )
Point -->6( 0 1 4 )
Point -->7( 1 0 4 )
Point -->8( 2 0 3 )
Point -->9( 3 0 2 )
Point -->10( 4 0 1 )
Point -->11( 4 1 0 )
Point -->12( 3 2 0 )
Point -->13( 2 3 0 )
Point -->14( 1 4 0 )
Point -->15( 1 1 3 )
Point -->16( 1 2 2 )
Point -->17( 2 1 2 )
Point -->18( 1 3 1 )
Point -->19( 2 2 1 )
Point -->20( 3 1 1 )
(1,1,3)(1,2,2)(2,1,2)(1,3,1)(2,2,1)(3,1,1)
il
5 0 0 0 0 0 0 1 2 3 4 4 3 2 1 1 1 2 1 2 3 
jl
0 5 0 4 3 2 1 0 0 0 0 1 2 3 4 1 2 1 3 2 1 
kl
0 0 5 1 2 3 4 4 3 2 1 0 0 0 0 3 2 2 1 1 1 
nn
0 0 0 0 0 1 1 1 1 1 2 2 2 2 2 1 1 1 1 2 1 1 1 2 2 1 1 2 2 2 1 2 2 2 2 0 2 2 2 2 0 0 2 2 2 0 0 0 2 2 0 0 0 0 2 0 0 0 0 1 0 0 0 1 1 0 0 1 1 1 0 1 1 1 1 0 1 2 2 2 0 1 1 2 2 0 0 1 2 2 0 1 1 1 2 0 0 1 1 2 0 0 0 1 2 
aa
0 1 2 3 4 0 1 2 3 4 0 1 2 3 4 0 1 2 3 0 0 1 2 0 1 0 1 0 1 2 0 0 1 2 3 0 0 1 2 3 0 1 0 1 2 0 1 2 0 1 0 1 2 3 0 0 1 2 3 0 0 1 2 0 1 0 1 0 1 2 0 0 1 2 3 0 0 0 1 2 0 0 1 0 1 0 1 0 0 1 0 0 1 2 0 0 1 0 1 0 0 1 2 0 0 
Other
0 1 2 6 5 4 3 10 9 8 7 14 13 12 11 15 16 17 18 19 20 
Data
0 1 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6 6 6 0 0 0 0 1 2 3 0 1 2 3 0 1 2 3 0 1 2 3 4 5 0 1 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6 6 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 0 0 21 

OOO
1 1 1 1 -1 -1 -1 -1 1 1 1 1 
OOO
-1 -1 -1 -1 -1 -1 -1 -1 1 1 1 1 
Error= 0.00025533
Npoint(npplo)=4	 Error(relative)= 0.000255271
times: compile 0.148442s, execution 0.110461s,  mpirank:0
 CodeAlloc : nb ptr  4534,  size :556696 mpirank: 0
Ok: Normal End
close  MUMPS_SEQ: MPI_Finalize
-- FreeFem++ v4.15 (mer. 01 oct. 2025 15:29:50 CEST - git v4.15-136-g831473f55)
   file : test.edp
 Load: lg_fem lg_mesh lg_mesh3 eigenvalue 
    1 : load"Element_Pk"
START
Point -->0( 4 0 0 )
Point -->1( 0 4 0 )
Point -->2( 0 0 4 )
Point -->3( 0 3 1 )
Point -->4( 0 2 2 )
Point -->5( 0 1 3 )
Point -->6( 1 0 3 )
Point -->7( 2 0 2 )
Point -->8( 3 0 1 )
Point -->9( 3 1 0 )
Point -->10( 2 2 0 )
Point -->11( 1 3 0 )
Point -->12( 1 1 2 )
Point -->13( 1 2 1 )
Point -->14( 2 1 1 )
(1,1,2)(1,2,1)(2,1,1)
il
4 0 0 0 0 0 1 2 3 3 2 1 1 1 2 
jl
0 4 0 3 2 1 0 0 0 1 2 3 1 2 1 
kl
0 0 4 1 2 3 3 2 1 0 0 0 2 1 1 
nn
0 0 0 0 1 1 1 1 2 2 2 2 1 1 1 2 1 1 2 2 1 2 2 2 0 2 2 2 0 0 2 2 0 0 0 2 0 0 0 1 0 0 1 1 0 1 1 1 0 1 2 2 0 1 1 2 0 0 1 2 
aa
0 1 2 3 0 1 2 3 0 1 2 3 0 1 2 0 0 1 0 1 0 0 1 2 0 0 1 2 0 1 0 1 0 1 2 0 0 1 2 0 0 1 0 1 0 0 1 2 0 0 0 1 0 0 1 0 0 1 0 0 
Other
0 1 2 5 4 3 8 7 6 11 10 9 12 13 14 
Data
0 1 2 3 3 3 4 4 4 5 5 5 6 6 6 0 0 0 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 3 3 3 4 4 4 5 5 5 6 6 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 0 0 15 

    2 : include "getARGV.idp" // for gestion of FreeFem++ argument and in version 3.10-1 FH
    2 :  // F. Hecht 
    3 :  // Usage:  getARGV(n,defaultvalue) // get the fist used default valeu
    4 :  //  or     getARGV(after,defaultvalue) // get the arg after after 
    5 :  // the type of delfaut value given the return type: int,double, string
    6 :  // Modif version 3.54-2  Jan 2018 (add ones include)
    7 :  IFMACRO(!getARGVidp)
    8 &  macro getARGVidp 1 //
    9 &  
   10 &  
   11 &  func int usedARGV(int n)
   12 & {
   13 &   int k=1,ii=1,kk=1,ret=-1;
   14 &   for(int i=1;i<ARGV.n;++i)
   15 &    {
   16 &    // cout <<i<< " "<< ARGV[i] << " " <<(ARGV[i]=="-v") << " " << kk << "==" 
   17 &    //      << n << " " << ARGV[i].rfind("dp") << " " <<ARGV[i].length-2  << endl;
   18 &         
   19 &        if(ARGV[i]=="-v") i++;
   20 &        else if(ARGV[i]=="-fglut") i++;
   21 &        else if(ARGV[i]=="-ffg") i++;
   22 &        else if(ARGV[i]=="-glut") i++;
   23 &        else if(ARGV[i]=="-f") i++;
   24 &        else if(ARGV[i]=="-nw") ii;
   25 &        else if(ARGV[i]=="-wait") ii;
   26 &        else if(ARGV[i]=="-ne") ii;
   27 &        else if(ARGV[i]=="-cd") ii;
   28 &        //else if(ARGV[i].rfind(".edp")==ARGV[i].length-4 ) ii;
   29 &        else if(i==1) ii;
   30 &        else if(kk++==n) {ret=i;}
   31 &       // else cout << " +++ \n";
   32 &      }
   33 &    //  cout << ret << endl;
   34 &     return ret;
   35 & }
   36 & 
   37 & func int usedARGV(string after)
   38 & {
   39 &   int ret=-1;
   40 &   for(int i=ARGV.n-1;i>=0;--i)        
   41 &        if(ARGV[i]==after) { ret=++i; break;}
   42 &   if(ARGV.n<ret) ret=-1;
   43 &   return ret;
   44 & }
   45 & 
   46 & func int getARGV(int n,int default)
   47 & {
   48 &    int d=default;
   49 &    int k=usedARGV(n);
   50 &    if(k>0) d=strtol(ARGV[k]);
   51 &     return d;
   52 & }
   53 & func real getARGV(int n,real default)
   54 & {
   55 &    real d=default;
   56 &    int k=usedARGV(n);
   57 &    if(k>0) d=strtod(ARGV[k]);
   58 &    return d;
   59 & }
   60 & func string getARGV(int n,string default)
   61 & {
   62 &    string d=default;
   63 &    int k=usedARGV(n);
   64 &    if(k>0) d=ARGV[k];
   65 &     return d;
   66 & }
   67 & 
   68 & func int getARGV(string after,int default)
   69 & {
   70 &    int d=default;
   71 &    int k=usedARGV(after);
   72 &    if(k>0) d=strtol(ARGV[k]);
   73 &     return d;
   74 & }
   75 & func real getARGV(string after,real default)
   76 & {
   77 &    real d=default;
   78 &    int k=usedARGV(after);
   79 &    if(k>0) d=strtod(ARGV[k]);
   80 &    return d;
   81 & }
   82 & func string getARGV(string after,string default)
   83 & {
   84 &    string d=default;
   85 &    int k=usedARGV(after);
   86 &    if(k>0) d=ARGV[k];
   87 &     return d;
   88 & }
   89 & 
   90 & /*
   91 & cout << getARGV(1,100) << endl;
   92 & cout << getARGV(2,200.) << endl;
   93 & cout << getARGV(3,"300.000") << endl;
   94 & cout << getARGV("-n"," xxx") << endl;
   95 & */
   96 & ENDIFMACRO
    8 @  macro getARGVidp 1 //
    9 @  
   10 @  
   11 @  func int usedARGV(int n)
   12 @ {
   13 @   int k=1,ii=1,kk=1,ret=-1;
   14 @   for(int i=1;i<ARGV.n;++i)
   15 @    {
   16 @    // cout <<i<< " "<< ARGV[i] << " " <<(ARGV[i]=="-v") << " " << kk << "==" 
   17 @    //      << n << " " << ARGV[i].rfind("dp") << " " <<ARGV[i].length-2  << endl;
   18 @         
   19 @        if(ARGV[i]=="-v") i++;
   20 @        else if(ARGV[i]=="-fglut") i++;
   21 @        else if(ARGV[i]=="-ffg") i++;
   22 @        else if(ARGV[i]=="-glut") i++;
   23 @        else if(ARGV[i]=="-f") i++;
   24 @        else if(ARGV[i]=="-nw") ii;
   25 @        else if(ARGV[i]=="-wait") ii;
   26 @        else if(ARGV[i]=="-ne") ii;
   27 @        else if(ARGV[i]=="-cd") ii;
   28 @        //else if(ARGV[i].rfind(".edp")==ARGV[i].length-4 ) ii;
   29 @        else if(i==1) ii;
   30 @        else if(kk++==n) {ret=i;}
   31 @       // else cout << " +++ \n";
   32 @      }
   33 @    //  cout << ret << endl;
   34 @     return ret;
   35 @ }
   36 @ 
   37 @ func int usedARGV(string after)
   38 @ {
   39 @   int ret=-1;
   40 @   for(int i=ARGV.n-1;i>=0;--i)        
   41 @        if(ARGV[i]==after) { ret=++i; break;}
   42 @   if(ARGV.n<ret) ret=-1;
   43 @   return ret;
   44 @ }
   45 @ 
   46 @ func int getARGV(int n,int default)
   47 @ {
   48 @    int d=default;
   49 @    int k=usedARGV(n);
   50 @    if(k>0) d=strtol(ARGV[k]);
   51 @     return d;
   52 @ }
   53 @ func real getARGV(int n,real default)
   54 @ {
   55 @    real d=default;
   56 @    int k=usedARGV(n);
   57 @    if(k>0) d=strtod(ARGV[k]);
   58 @    return d;
   59 @ }
   60 @ func string getARGV(int n,string default)
   61 @ {
   62 @    string d=default;
   63 @    int k=usedARGV(n);
   64 @    if(k>0) d=ARGV[k];
   65 @     return d;
   66 @ }
   67 @ 
   68 @ func int getARGV(string after,int default)
   69 @ {
   70 @    int d=default;
   71 @    int k=usedARGV(after);
   72 @    if(k>0) d=strtol(ARGV[k]);
   73 @     return d;
   74 @ }
   75 @ func real getARGV(string after,real default)
   76 @ {
   77 @    real d=default;
   78 @    int k=usedARGV(after);
   79 @    if(k>0) d=strtod(ARGV[k]);
   80 @    return d;
   81 @ }
   82 @ func string getARGV(string after,string default)
   83 @ {
   84 @    string d=default;
   85 @    int k=usedARGV(after);
   86 @    if(k>0) d=ARGV[k];
   87 @     return d;
   88 @ }
   89 @ 
   90 @ /**
   91 @ cout << getARGV(1,100) << endl;
   92 @ cout << getARGV(2,200.) << endl;
   93 @ cout << getARGV(3,"300.000") << endl;
   94 @ cout << getARGV("-n"," xxx") << endl;
   95 @ */
   96 @ 
    3 : load"Element_P3"
    4 : load"Element_P4" load : P4 
    5 : load"GMintegration" d= 3T Ordre= 0 d!k!/(d+k)!= 1 1 1 1 1  err= 1.99929e-12
 d= 3T Ordre= 1 d!k!/(d+k)!= 0.25 0.25 0.25 0.25 0.25  err= 1.99929e-12
 d= 3T Ordre= 2 d!k!/(d+k)!= 0.1 0.1 0.1 0.1 0.1  err= 1.99929e-12
Erreur dans la formule d'integration d=3 exact = 2 Nb Point = 15

    6 : load"GMintegration3D"
    7 : load"qf11to25"
    8 : load "MUMPS"init MUMPS_SEQ: MPI_Init

    9 : real k = getARGV("-waven",3.);
   10 : real c = 1;
   11 : real s= 0; 
   12 : func f =exp(1i*k*(x*c+y*s));
   13 : 
   14 : func Gxm = -1i*k*c*exp(1i*k*(x*c+y*s));
   15 : func GxM = -Gxm;
   16 : 
   17 : func Gym = -1i*k*s*exp(1i*k*(x*c+y*s));
   18 : func GyM = -Gym;
   19 : 
   20 : real lambda = 2*pi/k;
   21 : 
   22 : macro Grad(u) [dx(u),dy(u)]  )  // EOM
   23 : NewMacro Verfimacro(PK)
   24 # for (int npplo =4; npplo<=4; npplo+=10){
   25 #     mesh Th = square(npplo*1./lambda,npplo*1./lambda);    // global mesh
   26 #     fespace Uh(Th,PK);
   27 #     Uh <complex> u,v;
   28 #     //macro Grad(u) [dx(u),dy(u)] // EOM
   29 #     solve  pph(u,v,solver=sparsesolver) =
   30 #     int2d(Th,qft=qf25pT)(-(k^2)*u*v+Grad(u)'*Grad(v))
   31 #         +int1d(Th, 1,2,3,4,qft=qf25pT)( (1i*k*u)  * v )
   32 #             +int1d(Th, 1,qft=qf25pT)( (-(1i*k*f) - Gym) * v )
   33 #             +int1d(Th, 2,qft=qf25pT)( (-(1i*k*f) - GxM) * v )
   34 #             +int1d(Th, 3,qft=qf25pT)( (-(1i*k*f) - GyM) * v )
   35 #             +int1d(Th, 4,qft=qf25pT)( (-(1i*k*f) - Gxm) * v );
   36 #     real Err= abs(sqrt( int2d(Th,qft=qf25pT)(u-f)^2));
   37 #     Uh ur= real (u);
   38 #     plot (ur,fill=1,value=1);
   39 #     cout<<"Error= "<<Err/abs(sqrt( int2d(Th,qft=qf25pT)(f)^2))<<endl;
   40 #     cout<<"Npoint(npplo)="<<npplo<<"\t Error(relative)= "<<Err/abs(sqrt( int2d(Th)(f)^2))<<endl;
   41 # 
   42 # }
   43 # EndMacro )  
   45 : 
   46 : Verfimacro(PK4)
   24 @      
   25 @            // global mesh
   26 @      
   27 @       
   28 @     //macro Grad(u) [dx(u),dy(u)] // EOM
   29 @        
   30 @     
   31 @               
   32 @                    
   33 @                    
   34 @                    
   35 @                    
   36 @        
   37 @        
   38 @      
   39 @      
   40 @      
   41 @ 
   42 @ 
   43 @ 
   24 @ for (int npplo =4; npplo<=4; npplo+=10){
   25 @     mesh Th = square(npplo*1./lambda,npplo*1./lambda);    // global mesh
   26 @     fespace Uh(Th,PK4);
   27 @     Uh <complex> u,v;
   28 @     //macro Grad(u) [dx(u),dy(u)] // EOM
   29 @     solve  pph(u,v,solver=sparsesolver) =
   30 @     int2d(Th,qft=qf25pT)(-(k^2)*u*v+Grad(u)   [dx(u),dy(u)] '*Grad(v)   [dx(v),dy(v)] )
   31 @         +int1d(Th, 1,2,3,4,qft=qf25pT)( (1i*k*u)  * v )
   32 @             +int1d(Th, 1,qft=qf25pT)( (-(1i*k*f) - Gym) * v )
   33 @             +int1d(Th, 2,qft=qf25pT)( (-(1i*k*f) - GxM) * v )
   34 @             +int1d(Th, 3,qft=qf25pT)( (-(1i*k*f) - GyM) * v )
   35 @             +int1d(Th, 4,qft=qf25pT)( (-(1i*k*f) - Gxm) * v );
   36 @     real Err= abs(sqrt( int2d(Th,qft=qf25pT)(u-f)^2));
   37 @     Uh ur= real (u);
   38 @     plot (ur,fill=1,value=1);
   39 @     cout<<"Error= "<<Err/abs(sqrt( int2d(Th,qft=qf25pT)(f)^2))<<endl;
   40 @     cout<<"Npoint(npplo)="<<npplo<<"	 Error(relative)= "<<Err/abs(sqrt( int2d(Th)(f)^2))<<endl;
   41 @ 
   42 @ }
   43 @ ; sizestack + 1024 =4232  ( 3208 )

  -- Square mesh : nb vertices  =4 ,  nb triangles = 2 ,  nb boundary edges 4 rmdup= 0
  -- Solve : 
          min (-0.99048,-0.00086195)  max (1.00087,0.999175)
OOO
1 1 -1 -1 1 1 
OOO
-1 -1 -1 -1 1 1 
Error= 0.000297177
Npoint(npplo)=4	 Error(relative)= 0.000297109
times: compile 0.107543s, execution 0.063962s,  mpirank:0
 CodeAlloc : nb ptr  4534,  size :556696 mpirank: 0
Ok: Normal End
close  MUMPS_SEQ: MPI_Finalize
-- FreeFem++ v4.15 (mer. 01 oct. 2025 15:29:50 CEST - git v4.15-136-g831473f55)
   file : test.edp
 Load: lg_fem lg_mesh lg_mesh3 eigenvalue 
    1 : load"Element_Pk"
START
Point -->0( 4 0 0 )
Point -->1( 0 4 0 )
Point -->2( 0 0 4 )
Point -->3( 0 3 1 )
Point -->4( 0 2 2 )
Point -->5( 0 1 3 )
Point -->6( 1 0 3 )
Point -->7( 2 0 2 )
Point -->8( 3 0 1 )
Point -->9( 3 1 0 )
Point -->10( 2 2 0 )
Point -->11( 1 3 0 )
Point -->12( 1 1 2 )
Point -->13( 1 2 1 )
Point -->14( 2 1 1 )
(1,1,2)(1,2,1)(2,1,1)
il
4 0 0 0 0 0 1 2 3 3 2 1 1 1 2 
jl
0 4 0 3 2 1 0 0 0 1 2 3 1 2 1 
kl
0 0 4 1 2 3 3 2 1 0 0 0 2 1 1 
nn
0 0 0 0 1 1 1 1 2 2 2 2 1 1 1 2 1 1 2 2 1 2 2 2 0 2 2 2 0 0 2 2 0 0 0 2 0 0 0 1 0 0 1 1 0 1 1 1 0 1 2 2 0 1 1 2 0 0 1 2 
aa
0 1 2 3 0 1 2 3 0 1 2 3 0 1 2 0 0 1 0 1 0 0 1 2 0 0 1 2 0 1 0 1 0 1 2 0 0 1 2 0 0 1 0 1 0 0 1 2 0 0 0 1 0 0 1 0 0 1 0 0 
Other
0 1 2 5 4 3 8 7 6 11 10 9 12 13 14 
Data
0 1 2 3 3 3 4 4 4 5 5 5 6 6 6 0 0 0 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 3 3 3 4 4 4 5 5 5 6 6 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 0 0 15 

    2 : include "getARGV.idp" // for gestion of FreeFem++ argument and in version 3.10-1 FH
    2 :  // F. Hecht 
    3 :  // Usage:  getARGV(n,defaultvalue) // get the fist used default valeu
    4 :  //  or     getARGV(after,defaultvalue) // get the arg after after 
    5 :  // the type of delfaut value given the return type: int,double, string
    6 :  // Modif version 3.54-2  Jan 2018 (add ones include)
    7 :  IFMACRO(!getARGVidp)
    8 &  macro getARGVidp 1 //
    9 &  
   10 &  
   11 &  func int usedARGV(int n)
   12 & {
   13 &   int k=1,ii=1,kk=1,ret=-1;
   14 &   for(int i=1;i<ARGV.n;++i)
   15 &    {
   16 &    // cout <<i<< " "<< ARGV[i] << " " <<(ARGV[i]=="-v") << " " << kk << "==" 
   17 &    //      << n << " " << ARGV[i].rfind("dp") << " " <<ARGV[i].length-2  << endl;
   18 &         
   19 &        if(ARGV[i]=="-v") i++;
   20 &        else if(ARGV[i]=="-fglut") i++;
   21 &        else if(ARGV[i]=="-ffg") i++;
   22 &        else if(ARGV[i]=="-glut") i++;
   23 &        else if(ARGV[i]=="-f") i++;
   24 &        else if(ARGV[i]=="-nw") ii;
   25 &        else if(ARGV[i]=="-wait") ii;
   26 &        else if(ARGV[i]=="-ne") ii;
   27 &        else if(ARGV[i]=="-cd") ii;
   28 &        //else if(ARGV[i].rfind(".edp")==ARGV[i].length-4 ) ii;
   29 &        else if(i==1) ii;
   30 &        else if(kk++==n) {ret=i;}
   31 &       // else cout << " +++ \n";
   32 &      }
   33 &    //  cout << ret << endl;
   34 &     return ret;
   35 & }
   36 & 
   37 & func int usedARGV(string after)
   38 & {
   39 &   int ret=-1;
   40 &   for(int i=ARGV.n-1;i>=0;--i)        
   41 &        if(ARGV[i]==after) { ret=++i; break;}
   42 &   if(ARGV.n<ret) ret=-1;
   43 &   return ret;
   44 & }
   45 & 
   46 & func int getARGV(int n,int default)
   47 & {
   48 &    int d=default;
   49 &    int k=usedARGV(n);
   50 &    if(k>0) d=strtol(ARGV[k]);
   51 &     return d;
   52 & }
   53 & func real getARGV(int n,real default)
   54 & {
   55 &    real d=default;
   56 &    int k=usedARGV(n);
   57 &    if(k>0) d=strtod(ARGV[k]);
   58 &    return d;
   59 & }
   60 & func string getARGV(int n,string default)
   61 & {
   62 &    string d=default;
   63 &    int k=usedARGV(n);
   64 &    if(k>0) d=ARGV[k];
   65 &     return d;
   66 & }
   67 & 
   68 & func int getARGV(string after,int default)
   69 & {
   70 &    int d=default;
   71 &    int k=usedARGV(after);
   72 &    if(k>0) d=strtol(ARGV[k]);
   73 &     return d;
   74 & }
   75 & func real getARGV(string after,real default)
   76 & {
   77 &    real d=default;
   78 &    int k=usedARGV(after);
   79 &    if(k>0) d=strtod(ARGV[k]);
   80 &    return d;
   81 & }
   82 & func string getARGV(string after,string default)
   83 & {
   84 &    string d=default;
   85 &    int k=usedARGV(after);
   86 &    if(k>0) d=ARGV[k];
   87 &     return d;
   88 & }
   89 & 
   90 & /*
   91 & cout << getARGV(1,100) << endl;
   92 & cout << getARGV(2,200.) << endl;
   93 & cout << getARGV(3,"300.000") << endl;
   94 & cout << getARGV("-n"," xxx") << endl;
   95 & */
   96 & ENDIFMACRO
    8 @  macro getARGVidp 1 //
    9 @  
   10 @  
   11 @  func int usedARGV(int n)
   12 @ {
   13 @   int k=1,ii=1,kk=1,ret=-1;
   14 @   for(int i=1;i<ARGV.n;++i)
   15 @    {
   16 @    // cout <<i<< " "<< ARGV[i] << " " <<(ARGV[i]=="-v") << " " << kk << "==" 
   17 @    //      << n << " " << ARGV[i].rfind("dp") << " " <<ARGV[i].length-2  << endl;
   18 @         
   19 @        if(ARGV[i]=="-v") i++;
   20 @        else if(ARGV[i]=="-fglut") i++;
   21 @        else if(ARGV[i]=="-ffg") i++;
   22 @        else if(ARGV[i]=="-glut") i++;
   23 @        else if(ARGV[i]=="-f") i++;
   24 @        else if(ARGV[i]=="-nw") ii;
   25 @        else if(ARGV[i]=="-wait") ii;
   26 @        else if(ARGV[i]=="-ne") ii;
   27 @        else if(ARGV[i]=="-cd") ii;
   28 @        //else if(ARGV[i].rfind(".edp")==ARGV[i].length-4 ) ii;
   29 @        else if(i==1) ii;
   30 @        else if(kk++==n) {ret=i;}
   31 @       // else cout << " +++ \n";
   32 @      }
   33 @    //  cout << ret << endl;
   34 @     return ret;
   35 @ }
   36 @ 
   37 @ func int usedARGV(string after)
   38 @ {
   39 @   int ret=-1;
   40 @   for(int i=ARGV.n-1;i>=0;--i)        
   41 @        if(ARGV[i]==after) { ret=++i; break;}
   42 @   if(ARGV.n<ret) ret=-1;
   43 @   return ret;
   44 @ }
   45 @ 
   46 @ func int getARGV(int n,int default)
   47 @ {
   48 @    int d=default;
   49 @    int k=usedARGV(n);
   50 @    if(k>0) d=strtol(ARGV[k]);
   51 @     return d;
   52 @ }
   53 @ func real getARGV(int n,real default)
   54 @ {
   55 @    real d=default;
   56 @    int k=usedARGV(n);
   57 @    if(k>0) d=strtod(ARGV[k]);
   58 @    return d;
   59 @ }
   60 @ func string getARGV(int n,string default)
   61 @ {
   62 @    string d=default;
   63 @    int k=usedARGV(n);
   64 @    if(k>0) d=ARGV[k];
   65 @     return d;
   66 @ }
   67 @ 
   68 @ func int getARGV(string after,int default)
   69 @ {
   70 @    int d=default;
   71 @    int k=usedARGV(after);
   72 @    if(k>0) d=strtol(ARGV[k]);
   73 @     return d;
   74 @ }
   75 @ func real getARGV(string after,real default)
   76 @ {
   77 @    real d=default;
   78 @    int k=usedARGV(after);
   79 @    if(k>0) d=strtod(ARGV[k]);
   80 @    return d;
   81 @ }
   82 @ func string getARGV(string after,string default)
   83 @ {
   84 @    string d=default;
   85 @    int k=usedARGV(after);
   86 @    if(k>0) d=ARGV[k];
   87 @     return d;
   88 @ }
   89 @ 
   90 @ /**
   91 @ cout << getARGV(1,100) << endl;
   92 @ cout << getARGV(2,200.) << endl;
   93 @ cout << getARGV(3,"300.000") << endl;
   94 @ cout << getARGV("-n"," xxx") << endl;
   95 @ */
   96 @ 
    3 : load"Element_P3"
    4 : load"Element_P4" load : P4 
    5 : load"GMintegration" d= 3T Ordre= 0 d!k!/(d+k)!= 1 1 1 1 1  err= 1.99929e-12
 d= 3T Ordre= 1 d!k!/(d+k)!= 0.25 0.25 0.25 0.25 0.25  err= 1.99929e-12
 d= 3T Ordre= 2 d!k!/(d+k)!= 0.1 0.1 0.1 0.1 0.1  err= 1.99929e-12
Erreur dans la formule d'integration d=3 exact = 2 Nb Point = 15

    6 : load"GMintegration3D"
    7 : load"qf11to25"
    8 : load "MUMPS"init MUMPS_SEQ: MPI_Init

    9 : real k = getARGV("-waven",3.);
   10 : real c = 1;
   11 : real s= 0; 
   12 : func f =exp(1i*k*(x*c+y*s));
   13 : 
   14 : func Gxm = -1i*k*c*exp(1i*k*(x*c+y*s));
   15 : func GxM = -Gxm;
   16 : 
   17 : func Gym = -1i*k*s*exp(1i*k*(x*c+y*s));
   18 : func GyM = -Gym;
   19 : 
   20 : real lambda = 2*pi/k;
   21 : 
   22 : macro Grad(u) [dx(u),dy(u)]  )  // EOM
   23 : NewMacro Verfimacro(PK)
   24 # for (int npplo =50; npplo+=10){
   25 #     mesh Th = square(npplo*1./lambda,npplo*1./lambda);    // global mesh
   26 #     fespace Uh(Th,PK);
   27 #     Uh <complex> u,v;
   28 #     //macro Grad(u) [dx(u),dy(u)] // EOM
   29 #     solve  pph(u,v,solver=sparsesolver) =
   30 #     int2d(Th,qft=qf25pT)(-(k^2)*u*v+Grad(u)'*Grad(v))
   31 #         +int1d(Th, 1,2,3,4,qft=qf25pT)( (1i*k*u)  * v )
   32 #             +int1d(Th, 1,qft=qf25pT)( (-(1i*k*f) - Gym) * v )
   33 #             +int1d(Th, 2,qft=qf25pT)( (-(1i*k*f) - GxM) * v )
   34 #             +int1d(Th, 3,qft=qf25pT)( (-(1i*k*f) - GyM) * v )
   35 #             +int1d(Th, 4,qft=qf25pT)( (-(1i*k*f) - Gxm) * v );
   36 #     real Err= abs(sqrt( int2d(Th,qft=qf25pT)(u-f)^2));
   37 #     Uh ur= real (u);
   38 #     plot (ur,fill=1,value=1);
   39 #     cout<<"Error= "<<Err/abs(sqrt( int2d(Th,qft=qf25pT)(f)^2))<<endl;
   40 #     cout<<"Npoint(npplo)="<<npplo<<"\t Error(relative)= "<<Err/abs(sqrt( int2d(Th)(f)^2))<<endl;
   41 # 
   42 # }
   43 # EndMacro )  
   45 : 
   46 : Verfimacro(PK4)
   24 @     
   25 @            // global mesh
   26 @      
   27 @       
   28 @     //macro Grad(u) [dx(u),dy(u)] // EOM
   29 @        
   30 @     
   31 @               
   32 @                    
   33 @                    
   34 @                    
   35 @                    
   36 @        
   37 @        
   38 @      
   39 @      
   40 @      
   41 @ 
   42 @ 
   43 @ 
   24 @ for (int npplo =50; npplo+=10)
 Error line number 24, in file  macro: Verfimacro in test.edp, before  token )
syntax error
  current line = 24
Compile error : syntax error
	line number :24, )
error Compile error : syntax error
	line number :24, )
 code = 1 mpirank: 0
close  MUMPS_SEQ: MPI_Finalize
