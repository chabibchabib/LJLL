load"Element_Pk"
include "getARGV.idp"
load"Element_P3"
load"Element_P4"
load"GMintegration"
load"GMintegration3D"
load"qf11to25"
load "MUMPS"
real k = getARGV("-waven",3*0.5);
real c = 1;
real s= 0; 
func f =exp(1i*k*(x*c+y*s));

func Gxm = -1i*k*c*exp(1i*k*(x*c+y*s));
func GxM = -Gxm;

func Gym = -1i*k*s*exp(1i*k*(x*c+y*s));
func GyM = -Gym;

real lambda = 2*pi/k;

/*mesh Th1 = square(1,1);    // global mesh
fespace UH(Th1,PK);
fespace UH1(Th1,P1);

UH  ftest=x^7+y^7;
Th1=trunc(Th1,1,split=6);
UH1  ftest1=ftest-(x^7+y^7);
plot(ftest);
plot(ftest1);
cout<<endl;
//cout<<ftest[]<<endl;
cout<<ftest1[]<<endl;

exit(0);*/
macro Grad(u) [dx(u),dy(u)] // EOM
NewMacro Verfimacro(PK)
    int npplo =10;
    mesh Th = square(npplo,npplo);    // global mesh
    fespace Uh(Th,PK);
    Uh <complex> u,v;
    //macro Grad(u) [dx(u),dy(u)] // EOM
    solve  pph(u,v,solver=sparsesolver) =
    int2d(Th,qft=qf25pT)(-(k^2)*u*v+Grad(u)'*Grad(v))
        +int1d(Th, 1,2,3,4,qforder=10)( (1i*k*u)  * v )
            +int1d(Th, 1,qforder=10)( (-(1i*k*f) - Gym) * v )
            +int1d(Th, 2,qforder=10)( (-(1i*k*f) - GxM) * v )
            +int1d(Th, 3,qforder=10)( (-(1i*k*f) - GyM) * v )
            +int1d(Th, 4,qforder=10)( (-(1i*k*f) - Gxm) * v );
    real Err= abs(sqrt( int2d(Th,qft=qf25pT)(u-f)^2));
    Uh ur= real (u);
    Uh VisERr= abs(real(f)-ur);
    plot (ur,fill=1,value=1);
    plot (VisERr,fill=1,value=1);

    cout<<"Error= "<<Err/abs(sqrt( int2d(Th,qft=qf25pT)(f)^2))<<endl;
    cout<<"Npoint(npplo)="<<npplo<<"\t Error(relative)= "<<Err/abs(sqrt( int2d(Th)(f)^2))<<endl;

EndMacro

Verfimacro(PK);