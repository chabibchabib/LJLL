load"Element_Pk"
include "getARGV.idp"
load"Element_P3"
load"Element_P4"
load"GMintegration"
load"GMintegration3D"
load"qf11to25"
load "MUMPS"
real k = getARGV("-waven",3.);
real c = 1;
real s= 0; 
func f =exp(1i*k*(x*c+y*s));

func Gxm = -1i*k*c*exp(1i*k*(x*c+y*s));
func GxM = -Gxm;

func Gym = -1i*k*s*exp(1i*k*(x*c+y*s));
func GyM = -Gym;

real lambda = 2*pi/k;

/*mesh Th = square(1,1);    // global mesh
fespace UH(Th,PK5);
fespace UH1(Th,P1);

UH  ftest=x;
Th=trunc(Th,1,split=5);
UH1  ftest1=ftest;
plot(ftest);
plot(ftest1);

//cout<<ftest[]<<endl;
cout<<ftest1[]<<endl;

//exit(0);*/
macro Grad(u) [dx(u),dy(u)] // EOM
NewMacro Verfimacro(PK)
for (int npplo =50; npplo<=50; npplo+=10){
    mesh Th = square(npplo*1./lambda,npplo*1./lambda);    // global mesh
    fespace Uh(Th,PK);
    Uh <complex> u,v;
    //macro Grad(u) [dx(u),dy(u)] // EOM
    solve  pph(u,v,solver=sparsesolver) =
    int2d(Th,qft=qf25pT)(-(k^2)*u*v+Grad(u)'*Grad(v))
        +int1d(Th, 1,2,3,4,qft=qf25pT)( (1i*k*u)  * v )
            +int1d(Th, 1,qft=qf25pT)( (-(1i*k*f) - Gym) * v )
            +int1d(Th, 2,qft=qf25pT)( (-(1i*k*f) - GxM) * v )
            +int1d(Th, 3,qft=qf25pT)( (-(1i*k*f) - GyM) * v )
            +int1d(Th, 4,qft=qf25pT)( (-(1i*k*f) - Gxm) * v );
    real Err= abs(sqrt( int2d(Th,qft=qf25pT)(u-f)^2));
    Uh ur= real (u);
    plot (ur,fill=1,value=1);
    cout<<"Error= "<<Err/abs(sqrt( int2d(Th,qft=qf25pT)(f)^2))<<endl;
    cout<<"Npoint(npplo)="<<npplo<<"\t Error(relative)= "<<Err/abs(sqrt( int2d(Th)(f)^2))<<endl;

}
EndMacro

Verfimacro(PK6);