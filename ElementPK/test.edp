include "getARGV.idp"
load"Element_P3"
load"Element_P4"
/*load"GMintegration1D"
load"GMintegration"
load"GMintegration3D"*/
load"qf11to25"
load "MUMPS"
load"Element_PkLagrange"

real k = getARGV("-waven",3*0.5);
real c = 1;
real s= 0; 
func f =exp(1i*k*(x*c+y*s));

func Gxm = -1i*k*c*exp(1i*k*(x*c+y*s));
func GxM = -Gxm;

func Gym = -1i*k*s*exp(1i*k*(x*c+y*s));
func GyM = -Gym;

real lambda = 2*pi/k;

/*mesh Th1 = square(1,1);    // global mesh
Th1=trunc(Th1,x<0.5);

fespace UH(Th1,PKLagrange);
fespace UH1(Th1,P1);

UH  ftest=1;
Th1=trunc(Th1,1,split=10);
UH1  ftest1=ftest;
plot(ftest);
//plot(ftest1);
cout<<endl;
cout<<ftest[]<<endl;
//cout<<ftest1[]<<endl;
//fespace UHH(Th1,Pk3);

//exit(0);
*/
macro Grad(u) [dx(u),dy(u)] // EOM
NewMacro Verfimacro(PK)
    int npplo =2;
    mesh Th = square(npplo,npplo);    // global mesh
    fespace Uh(Th,PK);
    Uh <complex> u,v;
    //macro Grad(u) [dx(u),dy(u)] // EOM
    solve  pph(u,v,solver=sparsesolver) =
    int2d(Th,qft=qf25pT)(-(k^2)*u*v+Grad(u)'*Grad(v))+
    int1d(Th, 1,2,3,4,qforder=21)( (1i*k*u)  * v )
            +int1d(Th, 1,qforder=21)( (-(1i*k*f) - Gym) * v )
            +int1d(Th, 2,qforder=21)( (-(1i*k*f) - GxM) * v )
            +int1d(Th, 3,qforder=21)( (-(1i*k*f) - GyM) * v )
            +int1d(Th, 4,qforder=21)( (-(1i*k*f) - Gxm) * v );
    real Err= abs(sqrt( int2d(Th,qft=qf25pT)(u-f)^2));
    Uh ur= real (u);
    Uh VisERr= abs(real(f)-ur);
    plot (ur,fill=1,value=1);
    //plot (VisERr,fill=1,value=1);

    cout<<"Error= "<<Err/abs(sqrt( int2d(Th,qft=qf25pT)(f)^2))<<endl;
    cout<<"Npoint(npplo)="<<npplo<<"\t Error(relative)= "<<Err/abs(sqrt( int2d(Th)(f)^2))<<endl;

EndMacro

Verfimacro(PKLagrange);