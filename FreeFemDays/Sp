Pour motiver l'utilisation des éléments finis Pk d'ordre arbitraire, prenons l'exemple de l'équation d'Helmholtz, une EDP fondamentale qui apparaît dans de nombreux domaines (acoustique, électromagnétisme, sismique). Cette équation devient particulièrement difficile à résoudre lorsque la fréquence augmente (c’est-à-dire lorsque le nombre d’onde w est grand) ou lorsque l’on se rapproche d’un régime de résonance. Dans ces situations, la solution présente de fortes oscillations et une sensibilité accrue aux erreurs numériques, ce qui entraîne notamment des erreurs de phase (pollution numérique) et une dégradation de la précision des méthodes standards. Sur cette slide, j’ai rappelé une estimation a priori de l’erreur pour l’équation de Helmholtz discrétisée par éléments finis. la convergence pour Helmholtz devient délicate lorsque l’on se place à haute fréquence ou à proximité d’une résonance. Dans ce régime, le problème est mal conditionné et la solution est très sensible aux erreurs numériques. Comme on peut le voir dans la formule d’erreur, à fréquence w fixée, il existe essentiellement deux leviers pour améliorer la précision :
soit raffiner le maillage, c’est-à-dire diminuer h,soit augmenter l’ordre polynomial k des éléments finis.  Or, l’augmentation de l’ordre p offre un gain de convergence beaucoup plus efficace, potentiellement exponentiel. De plus, le raffinement du maillage est toujours possible grâce au meshers FreeFem En revanche, l’utilisation d’éléments finis d’ordre arbitraire n’est pas toujours disponible : dans notre logiciel, par exemple, l’ordre polynomial est limité à 4. C’est précisément ce constat qui motive l’intérêt et l’objectif de cette présentation
-------------------------------------------------------------
Afin de comprendre comment ajouter de nouveaux éléments de Lagrange classiques, nous nous sommes fortement inspirés des fichiers existants correspondant aux éléments P3 et P4 .En examinant de plus près ces fichiers, Un élément fini d’ordre 4, par exemple, est implémenté sous la forme d’une classe héritant de TPE, qui est elle-même la classe de base des éléments finis.Cette classe possède notamment comme attributs l’ordre d’interpolation k ainsi que le nombre de degrés de liberté associés à l’élément. Un tableau Data contient plusieurs informations topologiques, que nous expliquerons par la suite.
On dispose également de trois tableaux décrivant les fonctions de forme associées à l’élément en supposant que chaque fonction de forme, au point i, s’écrit sous la forme... ou lambda représente les coordonnées barycentriques, s sont les shift et ff un facteur de normalisation propre à l’élément.Finalement,les tableaux i,j,k contenant les coordonnées des points nodaux correspondants. 
Le constructeur de la classe fille commence par appeler celui de la classe parente, dont nous allons maintenant détailler les arguments et leur rôle.
-------------------------------------------------------------
(Classe mere constructeur details)
Comme vous pouvez le voir, l’appel au constructeur de la classe mère éléments finis est direct et simple, sauf pour le tableau Data dont le contenu et la structure nécessitent une attention particulière
-------------------------------------------------------------
Nous allons maintenant montrer à quoi ressemble ce tableau pour un élément P4, afin de se faire une idée de sa structure et de pouvoir généraliser facilement à des éléments d’ordre arbitraire.
(Data array details)
-------------------------------------------------------------
Une fois les informations topologiques sont completes. Nous passons aux tableaux contenant les informations sur les fonctions de forme. L'objectif ici est de construire des formules génériques capables de fournir les fonctions de forme pour n’importe quel ordre polynomial. Afin de vous montrer comment une telle formule peut être déduite, nous proposons l’exemple d’un élément fini P6, On considère un nœud défini par ses coordonnées barycentriques i,j,k where i+j+k=6. On commence par éliminer les nœuds situés sur les arêtes pour lesquels la coordonnée barycentrique lambda0 est inférieure à i. Une fois cette étape réalisée pour on procède de la même manière pour lambda1 et lambda2. On multiplie ensuite par le facteur de normalisation i!j!k! pour obtenir la fonction de forme normalisée. L’implémentation reste simple et a été encapsulée dans la fonction que neous presentons ici .., j'ai montré ici que la boucle correspondant à lambda0. 
-------------------------------------------------------------
Une fois ces attributs remplis, nous disposons de tous les éléments nécessaires pour définir notre classe TypeOfFE_Lagrange qui hérite de la classe TypeOfFE La taille de ses attributs dépend de l’ordre d’interpolation et sera initialisée dynamiquement à la volée. Il reste maintenant à interfacer cette classe afin qu’elle puisse être utilisée dans le DSL. Pour ce faire, nous allons déclarer un objet  static et l’ajouter à la liste des éléments finis connus grâce à l’opérateur AddNewFE.
-------------------------------------------------------------
Notre élément fini est maintenant prêt à l’utilisation. Cependant, un problème subsiste :l’intégration devient de plus en plus complexe à mesure que l’ordre polynomial augmente. Dans notre code, le degré maximal des polynômes pouvant être intégrés est limité à 25, ce qui justifie pleinement l’intérêt de proposer des formules d’intégration génériques pour gérer des ordres plus élevés.
Nous nous sommes alors intéressés aux formules d’intégration de Grundmann-Moller, qui proposent une formule d’intégration “magique” présentée ici, capable de s’adapter à n’importe quel degré polynomial d et à n’importe quelle dimension n. Cette méthode présente à la fois des avantages et des inconvénients, Certains aspects demandent de la prudence : les poids ne sont pas toujours positifs,
les coefficients s’expriment sous forme de factoriiels et de puissances, ce qui peut facilement entraîner des instabilités numériques. Il faut donc être vigilant lors de l’utilisation de cette formule de quadrature pour des ordres élevés.
-------------------------------------------------------------
Pour valider notre implémentation, nous avons testé un cas de référence : Poisson 2D avec conditions de Dirichlet aux bords. Sur cette figure, nous montrons la solution exacte, tandis que sur celle-ci, nous représentons l’erreur relative en norme L2 en fonction du nombre de points et pour différents ordres. On constate que l’erreur décroît lorsque l’ordre augmente, mais qu’au-delà d’un certain ordre, comme P5 on atteint la précision machine. Dans ce cas, des ordres supérieurs peuvent donner des résultats moins précis, ce qui peut s’expliquer par les problèmes d’instabilité numérique liés, par exemple, au conditionnement de la matrice.
-------------------------------------------------------------
Pour conclure cette présentation nous récapitulons les points essentiels, Nous avons conçu un élément générique PK en 2D, directement inspiré des éléments déjà existants.
Nous avons ensuite développé les formules de quadrature associées pour rendre cet élément opérationnel, mais celles-ci nécessitent une attention particulière, car elles ne sont pas toujours parfaitement précises.Pour l’avenir, plusieurs axes restent à explorer : tout d’abord, une vérification plus rigoureuse de la convergence ; ensuite, la gestion des instabilités numériques dans les formules de quadrature ; et enfin, l’extension de cette approche aux éléments Lagrange 3D, ce qui ouvrirait la voie à des simulations plus complexes.

