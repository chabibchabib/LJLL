// Poisson equation 2D
load "Element_P3"
load "Element_P4"
load"Element_PkLagrange"
load"qf11to25"
load "MUMPS"

func f =1;
func uex=0;
real[int][int] Umn(31);
//real[int][int] Fmn(31);
/*for (int i=0; i<=30; i++){
    //Fmn[i].resize(31);
    Umn[i].resize(31);
}*/
mesh Th = square(1000,1000);    // global mesh
for (int n =1; n<=30; n+2){
for (int m =1; m<=30; m+2){
    real Fmn=4*int2d(Th)(f*sin(m*pi*x)*sin(n*pi*y));
    real coef=Fmn/(pi^2*(n^2+m^2))*sin(n*pi*x)*sin(n*pi*y);
    uex[] = uex[]+coef * ( sin(m*pi*x)*sin(n*pi*y) );
    } 
    }
plot (uex,fill=1,value=1);



macro Grad(u) [dx(u),dy(u)] // EOM
NewMacro Verfimacro(Pp,fileArg)
for (int npplo =100; npplo<=100; npplo+=10){
    mesh Th = square(npplo,npplo);    // global mesh
    fespace Uh(Th,Pp);
    Uh u,v,uex;
    // Formulation Var
    solve  pph(u,v,solver=sparsesolver) =
    int2d(Th,qforder=15)(Grad(u)'*Grad(v))
    +int2d(Th,qforder=15)(f*v)//;
        + on(1,2,3,4, u = 0);
    //real Err= abs(sqrt( int2d(Th,qforder=15)(u-f)^2));
    //Uh ur= real (u);
    //plot (u,fill=1,value=1);
    //cout<<"Error= "<<Err/abs(sqrt( int2d(Th)(f)^2))<<endl;
    //fileArg<<"Npoint(npplo)="<<npplo<<"\t Error(relative)= "<<Err/abs(sqrt( int2d(Th)(f)^2))<<endl;


}
EndMacro


ofstream outfile("Poisson_2D.txt", append);
outfile<<"P="<<4<<endl;
//Verfimacro(P1,outfile)
